[![crate](https://img.shields.io/crates/v/trait_gen.svg)](https://crates.io/crates/trait-gen)
[![documentation](https://docs.rs/trait-gen/badge.svg)](https://docs.rs/trait-gen)
[![build status](https://github.com/blueglyph/trait_gen/actions/workflows/master.yml/badge.svg)](https://github.com/blueglyph/trait_gen/actions)
[![crate](https://img.shields.io/crates/l/trait_gen.svg)](https://github.com/blueglyph/trait_gen/blob/master/LICENSE-MIT)

<hr/>

<!-- TOC -->
* [The 'trait-gen' Crate](#the-trait-gen-crate)
  * [Compositions](#compositions)
  * [Tuples and Conditional Code](#tuples-and-conditional-code)
  * [Other features](#other-features)
* [Motivation](#motivation)
* [Compatibility](#compatibility)
* [Releases](#releases)
* [Licence](#licence)
<!-- TOC -->

<hr/>

# The 'trait-gen' Crate

This crate provides attribute macros that generate the attached implementation for all the
types given in argument. It was first intended for trait implementations, hence the crate name,
but it can also be used for any generic implementation.

Here is a simple example:

```rust
# use trait_gen::trait_gen;
# trait MyLog { fn my_log2(self) -> u32; }
#[trait_gen(T -> u8, u16, u32, u64, u128)]
impl MyLog for T {
    fn my_log2(self) -> u32 {
        T::BITS - 1 - self.leading_zeros()
    }
}
```

## Compositions
`trait_gen` also replaces the content of inner attributes, so it's possible to chain them
and extend the previous implementation to references and smart pointers:

```rust
#[trait_gen(T -> u8, u16, u32, u64, u128)]
#[trait_gen(U -> &T, &mut T, Box<T>)]
impl MyLog for U {
    /// Logarithm base 2 for `${U}`
    fn my_log2(self) -> u32 {
        MyLog::my_log2(*self)
    }
}
```

## Tuples and Conditional Code

A more concise format can be used for compositions when the type lists are the same for
several arguments (in other words, _permutations with repetitions_, or _tuples_):

```rust,ignore
#[trait_gen(T, U -> u8, u16, u32)]
```

In the following example, we also show the conditional attribute `trait_gen_if`, which
offers more flexibility in the implementations. The condition has the general format
`<argument> in <types>`, or its negation, `!<argument> in <types>`. The code is respectively
included or skipped when the argument is identical to one of the types.

```rust
use trait_gen::{trait_gen, trait_gen_if};

#[derive(Clone, PartialEq, Debug)]
struct Wrapper<T>(T);

#[trait_gen(T, U -> u8, u16, u32)]
// The types T and U must be different to avoid the compilation error
// "conflicting implementation in crate `core`: impl<T> From<T> for T"
#[trait_gen_if(!T in U)]
impl From<Wrapper<U>> for Wrapper<T> {
    /// converts ${U} to ${T}
    fn from(value: Wrapper<U>) -> Self {
        Wrapper(T::try_from(value.0)
            .expect(&format!("overflow when converting {} to ${T}", value.0)))
    }
}
```

which will give us all the conversions from/to `u8`, `u16`, and `u32`, except from the
same type since they're already covered by the blanket implementation in the standard library.

_Thanks to **Daniel Vigovszky** for giving me this idea! He first implemented it, although differently, in a fork called [conditional_trait_gen](https://github.com/vigoo/conditional_trait_gen). I had pondered about some use-cases that would require such a feature in an old post but never got around to implementing it until version 1.1.0._

## Other features

Please read the [crate documentation](https://docs.rs/trait-gen) for more details.

# Motivation

There are other ways to generate multiple implementations:
- copy them manually (which is tedious, error-prone, and annoying to maintain)
- use a declarative macro
- use a blanket implementation

Using a **declarative macro** would give something like this:

```rust
macro_rules! impl_my_log {
    ($($t:ty)*) => (
        $(impl MyLog for $t {
            fn my_log2(self) -> u32 {
                $t::BITS - 1 - self.leading_zeros()
            }
        })*
    )
}

impl_my_log! { u8 u16 u32 u64 u128 }
```

It's OK, but it's harder to read than native code, and IDEs can't often provide contextual help or apply refactoring in the macro code. It's also quite annoying and unhelpful to get this result when we're looking for the definition of a method when it has been generated by a declarative macro:

```rust
impl_my_log! { u8 u16 u32 u64 u128 }
```

Using a **blanket implementation** is very powerful but has other drawbacks:
- It forbids any other implementation except for types of the same crate that are not already under the blanket implementation, so it only works when the implementation can be written for all bound types, current and future.
- Finding a trait that corresponds to what we need to write is not always possible. The `num` crate provides a lot of help for primitives, for instance, but not everything is covered.
- Doing the implementation for a whole range of types isn't always desirable.
- Even when the operations and constants are covered by traits, it quickly requires a long list of trait bounds.

# Compatibility

The `trait-gen` crate is tested for rustc **1.61.0** and stable on Windows 64-bit and Linux 64/32-bit platforms.

# Releases

[RELEASES.md](RELEASES.md) keeps a log of all the releases (most are on the [GitHub release page](https://github.com/blueglyph/trait_gen/releases), too). 

# Licence

This code is licensed under either [MIT License](https://choosealicense.com/licenses/mit/) or [Apache License 2.0](https://choosealicense.com/licenses/apache-2.0/), at your option.
